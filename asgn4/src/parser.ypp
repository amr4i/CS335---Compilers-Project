%{
	#include <math.h>
	#include <cstdio> 
	#include <map>
	#include <utility>
	#include <vector>
	#include <string>
	#include <iostream>
	#include <algorithm>
	#include <iomanip>
	#include <stdarg.h>
	#include <cstdlib>
	#define YYDEBUG 1
	#include "src/genTAC.cpp"
	#include "y.tab.h"
	using namespace std;
	extern void yyerror(char *c);
	//extern int 1234555;

	int yylex(void);

	// SymTable* ST = new SymTable();
%}
// yylineno replaced by 1234555
//%option 1234555

%union{
	int iVal;
	char *sVal;
	char cVal;
	struct genNode* node;	
};

%nonassoc IFX
%nonassoc ELSE

%expect 1

%token BASE BOOL BREAK CASE CATCH CHAR CLASS CONST CONTINUE DEFAULT DO ELSE FALSE FINALLY FOR FOREACH GOTO IF IN INT LONG NAMESPACE NEW NULL_LIT OBJECT PARAMS PRIVATE PROTECTED PUBLIC REF RETURN STRING STRUCT SWITCH THIS THROW TRUE TRY TYPEOF USING VOID WHILE ID DINT_LITERAL HDINT_LITERAL SIMPLE_ESC_SEQ CHAR_LITERAL REG_STR_LITERAL VER_STR_LITERAL  DQM DCLN INCR DECR RAND ROR REQ RNE LE GE APLUS AMINUS AMULT ADIV AMOD AAND AOR ACARET LSHIFT LSHIFTEQ RSHIFT WHERE

%token <sVal> TRUE FALSE DCLN RSHIFT RSHIFTEQ INT CHAR LONG OBJECT STRING BOOL ID CHAR_LITERAL REG_STR_LITERAL VER_STR_LITERAL NULL_LIT THIS INCR DECR 
%token <sVal> NEW PUBLIC PROTECTED PRIVATE
%token <iVal> DINT_LITERAL HDINT_LITERAL

%token <cVal>

//%type <sVal> boolean_literal string_literal right_shift null_literal 
//%type <sVal> right_shift_assignment qualified_identifier qualified_alias_member namespace_or_type_name namespace_name type_name
//%type <sVal> integral_type numeric_type class_type simple_type non_nullable_value_type nullable_type


%type <node> literal boolean_literal integer_literal string_literal character_literal null_literal modifiers
%type <node> namespace_name namespace_or_type_name type_name qualified_identifier identifier start

%type <node> type non_array_type array_type simple_type nullable_type numeric_type class_type integral_type non_nullable_value_type
%type <node> variable_reference expression argument_list argument argument_value argument_name primary_no_array_creation_expression
%type <node> primary_expression array_creation_expression parenthesized_expression postfix_expression
%type <node> unary_expression_not_plusminus
%type <node> pre_decrement_expression pre_increment_expression multiplicative_expression unary_expression additive_expression shift_expression
%type <node> relational_expression equality_expression and_expression exclusive_or_expression 
%type <node> inclusive_or_expression conditional_and_expression conditional_or_expression null_coalescing_expression
%type <node> conditional_expression non_assignment_expression labeled_statement declaration_statement embedded_statement
%type <node> block empty_statement expression_statement selection_statement iteration_statement jump_statement try_statement using_statement statement_list 
%type <node> local_variable_declaration local_variable_type local_variable_declarators local_variable_declarator local_variable_initializer 
%type <node> compilation_unit namespace_member_declarations using_directives namespace_declaration namespace_body using_directive
%type <node> using_namespace_directive qualified_alias_member modifier class_member_declarations formal_parameter_list
%type <node> method_header fixed_parameters fixed_parameter member_access invocation_expression element_access this_access base_access
%type <node> object_creation_expression typeof_expression default_value_expression assignment constant_expression boolean_expression
%type <node> statement class_declaration class_base class_body method_body member_name
%type <sVal> assignment_operator rank_specifier 

%%

start :	compilation_unit	{ $$ = $1;}
		;

/*B.1.6 Identifiers*/
identifier : 	ID 		
				{
					if(ST->GetVar(string($1)) == NULL){
						ST->AddVar(string($1));
					}
					genNode* newNode = new genNode();
					newNode->place = string($1);
					$$ = newNode;
				}
				;

/*B.1.8 Literals*/ 
literal : boolean_literal 	
		{  
			$$ = $1;
		}
		| integer_literal 	
		{  
			$$ = $1;
		}
		| character_literal 	
		{  
			$$ = $1;
		}
		| string_literal 	
		{  
			$$ = $1;
		}
		| null_literal	
		{  
			$$ = $1;
		}
		;

boolean_literal : TRUE 	{	
			genNode* newNode = new genNode();
			$$ = newNode;
			$$->type = "bool";
			$$->place = string($1);
			$$->isLit = true;	
		}
		| FALSE		{ 	
			genNode* newNode = new genNode();
			$$ = newNode;
			$$->type = "bool";
			$$->place = string($1);
			$$->isLit = true;
		}
		;

integer_literal : DINT_LITERAL 	{ 
			genNode* newNode = new genNode();
			$$ = newNode;
			$$->type = "int";
			$$->place = to_string($1);
			$$->isLit = true;
		}
		| HDINT_LITERAL	{
			genNode* newNode = new genNode();
			$$ = newNode;
			$$->type = "int";
			$$->place = to_string($1);
			$$->isLit = true;
		}
		;

character_literal : CHAR_LITERAL	{
			genNode* newNode = new genNode();
			$$ = newNode;
			$$->type = "char";
			$$->place = string($1);
			$$->isLit = true;
		}
		;
		
/*
simple_escape_sequence : 	SIMPLE_ESC_SEQ 	{  }
							;
*/

string_literal : REG_STR_LITERAL 	{
			genNode* newNode = new genNode();
			$$ = newNode;
			$$->type = "string";
			$$->place = string($1);
			$$->isLit = true;
		}
		| VER_STR_LITERAL	{
			genNode* newNode = new genNode();
			$$ = newNode;
			$$->type = "string";
			$$->place = string($1);
			$$->isLit = true;
		}
		;

null_literal :	NULL_LIT	{
			genNode* newNode = new genNode();
			$$ = newNode;
			$$->type = "null";
			$$->place = string($1);
			$$->isLit = true;
		}
		;

/*B.1.9 Operators*/ 
right_shift : RSHIFT	{}
		;
right_shift_assignment : RSHIFTEQ	{}
		;

/*B.2.1 Basic concepts*/ 
namespace_name : namespace_or_type_name	{ $$ = $1; }
		;
type_name : namespace_or_type_name	{ $$ = $1; }
		;
namespace_or_type_name : qualified_identifier 	{ $$ = $1; }
		| qualified_alias_member	{ $$ = $1; }
		;

/*B.2.2 Types*/ 
type : non_array_type 	{ $$ = $1;}
		| array_type 	{ 
			$$ = $1;
		}
		;		;
non_array_type : type_name 	{ 
			$$ = $1; 
		}
		| simple_type 	{ 
			$$ = $1; 
		}
		| nullable_type	{ 
			$$ = $1; 
		}
		;
simple_type : numeric_type 	{ 
			$$ = $1; 
		}
		| class_type 	{ 
			$$ = $1; 
		}
		| BOOL	{
			genNode* newNode = new genNode();
			$$ = newNode;
			$$->place = "bool"; 
			$$->type = "bool";
		}
		;
numeric_type : integral_type 	{ $$ = $1; }
		;
integral_type : INT 	{
			genNode* newNode = new genNode();
			$$ = newNode;
			$$->place = "int"; 
			$$->type = "int";
		}
		| LONG 	{
			genNode* newNode = new genNode();
			$$ = newNode;
			$$->place = "long"; 
			$$->type = "long";
		}
		| CHAR	{
			genNode* newNode = new genNode();
			$$ = newNode;
			$$->place = "char"; 
			$$->type = "char";
		}
		;
nullable_type : non_nullable_value_type '?'	{
			$$ = $1;
			$$->place += " ?"; 
			// Consider the type of this node
		}
		;
non_nullable_value_type : simple_type	{ $$ = $1; }
		;


class_type : OBJECT 	{ 
			genNode* newNode = new genNode();
			$$ = newNode;
			$$->place = string($1);
		}
		| STRING	{ 
			genNode* newNode = new genNode();
			$$ = newNode;
			$$->place = string($1);
		}
		;

/*B.2.3 Variables*/ 
variable_reference : expression	{ $$ = $1; }
		;

/*B.2.4 Expressions*/ 
argument_list : argument 	{ }
		| argument_list ',' argument	{ }
		;
argument : argument_value 	{ }
		| argument_name argument_value	{ }
		;
argument_name : identifier ':'	{ }
		;
argument_value : expression 	{ }
		| REF variable_reference 	{ }
		;
primary_expression : primary_no_array_creation_expression 	{ $$ = $1; }
		| array_creation_expression	{ $$ = $1; }
		| parenthesized_expression	{ $$ = $1; }
		;
primary_no_array_creation_expression : literal 	{ $$ = $1; }
		| member_access 	{ $$ = $1; }
		| invocation_expression 	{ $$ = $1; }
		| element_access 	{ $$ = $1; }
		| this_access 	{ $$ = $1; }
		| base_access 	{ $$ = $1; }
		| object_creation_expression 	{ $$ = $1; }
		| typeof_expression 	{ $$ = $1; }
		| default_value_expression	{ $$ = $1; }
		;

parenthesized_expression : '(' expression ')'	{ 
			// string tmpVar = symTable->GenTemp($2->type, "simple", -1);
			$$ = $2;
			// $$ -> place = tmpVar;
			// gen2OpCode($$, "=", $2);
		}
		;
member_access : primary_expression '.' identifier 	{  }
			{  }
		| predefined_type '.' identifier 	{  }
		| qualified_alias_member '.' identifier	{  }
		;

predefined_type : BOOL 	
		{
			genNode* newNode = new genNode();
			
  		}
		| CHAR 	{  }
		| INT 	{  }
		| LONG 	{  }
		| OBJECT 	{  }
		| STRING 	{  }
		;

invocation_expression : primary_no_array_creation_expression '(' ')' 	{  }
		| primary_no_array_creation_expression '(' argument_list ')'	{  }
		| qualified_identifier '(' ')' 	{  }
		| qualified_identifier '(' argument_list ')'	{  }
		;

element_access : primary_no_array_creation_expression '[' expression_list ']'	{  }
		;

expression_list : expression  	{  }
		| expression ',' expression	{  }
		;
this_access : THIS	{ 
			genNode* newNode = new genNode();
			$$ = newNode;
			$$->place = $1; 
		}
		;
base_access : BASE '.' identifier 	{  }
		| BASE '[' expression_list ']'	{  }
		;
postfix_expression : 	primary_expression 		{ $$ = $1; }
		| qualified_identifier 		{ $$ = $1; }
		;

object_creation_expression : NEW type '(' ')' 	{  }
		| NEW type '(' argument_list ')' 	{  }
		| NEW type '(' ')' object_or_collection_initializer 	{  }
		| NEW type '(' argument_list ')' object_or_collection_initializer 	{  }
		;
object_or_collection_initializer : object_initializer 	{  }
		| collection_initializer	{  }
		;
object_initializer : '{' '}' 	{  }
		| '{' member_initializer_list '}' 	{  }
		| '{' member_initializer_list ',' '}'	{  }
		;
member_initializer_list : member_initializer 	{  }
		| member_initializer_list ',' member_initializer	{  }
		;
member_initializer : identifier '=' initializer_value	{  }
		;
initializer_value : expression 	{  }
		| object_or_collection_initializer	{  }
		;
collection_initializer : '{' element_initializer_list '}' 	{  }
		| '{' element_initializer_list ',' '}'	{  }
		;
element_initializer_list : element_initializer 	{  }
		| element_initializer_list ',' element_initializer	{  }
		;
element_initializer : non_assignment_expression 	{  }
		| '{' expression_list '}'	{  }
		;
array_creation_expression :	NEW non_array_type '[' expression_list ']' 	{  }
		| NEW non_array_type '[' expression_list ']' rank_specifier 	{  }
		| NEW non_array_type '[' expression_list ']' array_initializer 	{  }
		| NEW non_array_type '[' expression_list ']' rank_specifier array_initializer 	{  }
		| NEW array_type array_initializer 	{  }
		| NEW rank_specifier array_initializer	{  }
		;

typeof_expression : TYPEOF '(' type ')' 	{  }
		| TYPEOF '(' VOID ')'	{  }
		;
default_value_expression : DEFAULT '(' type ')'	{  }
		;
unary_expression_not_plusminus : postfix_expression 	{ $$ = $1; }
		| '!' unary_expression 	{  }
		| '~' unary_expression 	{  }
		| cast_expression	{  }
		;
unary_expression : unary_expression_not_plusminus 	{ $$ = $1; }
		| '+' unary_expression 	{ $$ = $2; }
		| '-' unary_expression 	{ 
			$$ = $2;
			//string tmpVar = GenTemp($2->type, "simple", curEnv->addTable[$2->place]->width);
			//$$->place = tmpVar;
			////////////////// I guess this function will carry out the above mentioned statements ////////////////////////////
			getPreUnaryOpCode("-", $$, $2, 1234555);
		}
		;
pre_increment_expression : INCR unary_expression
		{  
			$$ = $2;
			getPreUnaryOpCode("++", $$, $2, 1234555);
		}
		;
pre_decrement_expression : DECR unary_expression	
		{  
			$$ = $2;
			getPreUnaryOpCode("--", $$, $2, 1234555);
		}
		;
cast_expression : parenthesized_expression unary_expression_not_plusminus	{ }
		| '(' qualified_identifier rank_specifier ')' unary_expression  { }
  		| '(' simple_type ')' unary_expression { }
  		| '(' VOID ')' unary_expression { }
  		;

multiplicative_expression :	unary_expression 	{ $$ = $1; }
		| multiplicative_expression '*' unary_expression 	
		{ 
			genNode* newNode = new genNode();
			$$ = newNode;
			$$->code = $1->code;
			gen2OpCode($$, "*", $1, $3, 1234555);
			//$$->code.pb($$->code.end(), $3->code.begin(), $3->code.end());
		}
		| multiplicative_expression '/' unary_expression 	
		{ 
			genNode* newNode = new genNode();
			$$ = newNode;
			$$->code = $1->code;
			$$->code.insert($$->code.end(), $3->code.begin(), $3->code.end());
			gen2OpCode($$, "/", $1, $3, 1234555);
		}
		| multiplicative_expression '%' unary_expression	
		{ 
			genNode* newNode = new genNode();
			$$ = newNode;
			$$->code = $1->code;
			$$->code.insert($$->code.end(), $3->code.begin(), $3->code.end());
			gen2OpCode($$, "%", $1, $3, 1234555);
		}
		;

additive_expression : multiplicative_expression 	{ $$ = $1; }
		| additive_expression '+' multiplicative_expression 	
		{  
			genNode* newNode = new genNode();
			$$ = newNode;
			$$->code = $1->code;
			$$->code.insert($$->code.end(), $3->code.begin(), $3->code.end());
			gen2OpCode($$, "+", $1, $3, 1234555);
		}
		| additive_expression '-' multiplicative_expression	
		{  
			genNode* newNode = new genNode();
			$$ = newNode;
			$$->code = $1->code;
			$$->code.insert($$->code.end(), $3->code.begin(), $3->code.end());
			gen2OpCode($$, "-", $1, $3, 1234555);
		}
		;

shift_expression : additive_expression 	{ $$ = $1; }
		| shift_expression LSHIFT additive_expression 	
		{ 
			genNode* newNode = new genNode();
			$$ = newNode;
			$$->code = $1->code;
			$$->code.insert($$->code.end(), $3->code.begin(), $3->code.end());
			gen2OpCode($$, "<<", $1, $3, 1234555);
		}
		| shift_expression right_shift additive_expression	
		{ 
			genNode* newNode = new genNode();
			$$ = newNode;
			$$->code = $1->code;
			$$->code.insert($$->code.end(), $3->code.begin(), $3->code.end());
			gen2OpCode($$, ">>", $1, $3, 1234555);
		}
		;
relational_expression : shift_expression 	{ $$ = $1; }
		| relational_expression '<' shift_expression 	
		{ 
			genNode* newNode = new genNode();
			$$ = newNode;
			$$->code = $1->code;
			$$->code.insert($$->code.end(), $3->code.begin(), $3->code.end());
			gen2OpCode($$, "<", $1, $3, 1234555);
		}
		| relational_expression '>' shift_expression 	
		{ 
			genNode* newNode = new genNode();
			$$ = newNode;
			$$->code = $1->code;
			$$->code.insert($$->code.end(), $3->code.begin(), $3->code.end());
			gen2OpCode($$, ">", $1, $3, 1234555);
		}
		| relational_expression LE shift_expression 	
		{ 
			genNode* newNode = new genNode();
			$$ = newNode;
			$$->code = $1->code;
			$$->code.insert($$->code.end(), $3->code.begin(), $3->code.end());
			gen2OpCode($$, "<=", $1, $3, 1234555);
		}
		| relational_expression GE shift_expression 	
		{ 
			genNode* newNode = new genNode();
			$$ = newNode;
			$$->code = $1->code;
			$$->code.insert($$->code.end(), $3->code.begin(), $3->code.end());
			gen2OpCode($$, ">=", $1, $3, 1234555);
		}
equality_expression : relational_expression 	{ $$ = $1; }
		| equality_expression REQ relational_expression 	{  }
		{ 
			genNode* newNode = new genNode();
			$$ = newNode;
			$$->code = $1->code;
			$$->code.insert($$->code.end(), $3->code.begin(), $3->code.end());
			gen2OpCode($$, "==", $1, $3, 1234555);
		}
		| equality_expression RNE relational_expression	
		{ 
			genNode* newNode = new genNode();
			$$ = newNode;
			$$->code = $1->code;
			$$->code.insert($$->code.end(), $3->code.begin(), $3->code.end());
			gen2OpCode($$, "!=", $1, $3, 1234555);
		}
		;
and_expression : equality_expression 	{ $$ = $1; }
		| and_expression '&' equality_expression	
		{ 
			genNode* newNode = new genNode();
			$$ = newNode;
			$$->code = $1->code;
			$$->code.insert($$->code.end(), $3->code.begin(), $3->code.end());
			gen2OpCode($$, "&", $1, $3, 1234555);
		}
		;
exclusive_or_expression : and_expression 	{ $$ = $1; }
		| exclusive_or_expression '^' and_expression	
		{ 
			genNode* newNode = new genNode();
			$$ = newNode;
			$$->code = $1->code;
			$$->code.insert($$->code.end(), $3->code.begin(), $3->code.end());
			gen2OpCode($$, "^", $1, $3, 1234555);
		}
		;
inclusive_or_expression : exclusive_or_expression 	{ $$ = $1; }
		| inclusive_or_expression '|' exclusive_or_expression	
		{ 
			genNode* newNode = new genNode();
			$$ = newNode;
			$$->code = $1->code;
			$$->code.insert($$->code.end(), $3->code.begin(), $3->code.end());
			gen2OpCode($$, "|", $1, $3, 1234555);
		}
		;
conditional_and_expression : inclusive_or_expression 	{ $$ = $1;  }
		| conditional_and_expression RAND inclusive_or_expression
		{ 
			genNode* newNode = new genNode();
			$$ = newNode;
			$$->code = $1->code;
			$$->code.insert($$->code.end(), $3->code.begin(), $3->code.end());
			gen2OpCode($$, "&&", $1, $3, 1234555);
		}
		;
conditional_or_expression : conditional_and_expression 	{ $$ = $1; }
		| conditional_or_expression ROR conditional_and_expression
		{ 
			genNode* newNode = new genNode();
			$$ = newNode;
			$$->code = $1->code;
			$$->code.insert($$->code.end(), $3->code.begin(), $3->code.end());
			gen2OpCode($$, "||", $1, $3, 1234555);
		}
		;
null_coalescing_expression : conditional_or_expression 	{ $$ = $1; }
		| conditional_or_expression DQM null_coalescing_expression	
		{ 
			genNode* newNode = new genNode();
			$$ = newNode;
			$$->code = $1->code;
			$$->code.insert($$->code.end(), $3->code.begin(), $3->code.end());
			gen2OpCode($$, "??", $1, $3, 1234555);
		}
		;
conditional_expression : null_coalescing_expression 	{ $$ = $1; }
		| null_coalescing_expression '?' expression ':' expression	
		{ 
			genNode* newNode = new genNode();
			$$ = newNode;
			getCECode($$, $1, $3, $5, 1234555);
		}
		;
assignment : unary_expression assignment_operator expression	{  
			// assignment_operator is a string
			$$ = $1;	
		}
		;
assignment_operator : '=' 	{ $$ = "="; }
		| APLUS 	{ $$ = "+="; }
		| AMINUS 	{ $$ = "-="; }
		| AMULT 	{ $$ = "*="; }
		| ADIV 	{ $$ = "/="; }
		| AMOD 	{ $$ = "%="; }
		| AAND 	{ $$ = "&="; }
		| AOR 	{ $$ = "|="; }
		| ACARET 	{ $$ = "^="; }
		| LSHIFTEQ 	{ $$ = "<<="; }
		| right_shift_assignment	{ $$ = ">>="; }
		;
expression : non_assignment_expression 	{ $$ = $1; }
		| assignment	{ $$ = $1; }
		;
non_assignment_expression : conditional_expression	{  }
		;
constant_expression : expression	{ $$ = $1; }
		;
boolean_expression : expression	{ $$ = $1; }
		;

/*B.2.5 Statements*/ 
statement :	labeled_statement 	{  $$ = $1;  }
		| declaration_statement 	{ $$ = $1; }
		| embedded_statement	{ $$ = $1; }
		;
embedded_statement : block 	{ $$ = $1; }
		| empty_statement 	{ $$ = $1; }
		| expression_statement 	{ $$ = $1; }
		| selection_statement 	{ $$ = $1; }
		| iteration_statement 	{ $$ = $1; }
		| jump_statement 	{ $$ = $1; }
		| try_statement 	{ $$ = $1; }
		| using_statement	{ $$ = $1; }
		;
block : block_start '{' '}' block_end 	{ 	}
		| block_start '{' statement_list '}' block_end	{   }
		;
block_start : epsilon	{	}
		;
block_end : epsilon	{	}
		;
statement_list : statement 	{ $$ = $1; }
		| statement_list statement	{ $$ = $1; }
		;
empty_statement : ';'	{  }
		;
labeled_statement :	identifier ':' statement	{  }
		;
declaration_statement :	local_variable_declaration ';'	 	{ $$ = $1; }
		| local_constant_declaration ';'	{  }
		;
local_variable_declaration : local_variable_type local_variable_declarators	{ $$ = $1; }
		;
local_variable_type : type 	{ $$ = $1; }
		;
local_variable_declarators : local_variable_declarator 	{ $$ = $1; }
		| local_variable_declarators ',' local_variable_declarator	{  }
		;
local_variable_declarator : identifier 	{ $$ = $1; }
		| identifier '=' local_variable_initializer	{ $$ = $1; }
		;
local_variable_initializer : expression 	{  }
		| array_initializer	{  }
		;
local_constant_declaration :  CONST type constant_declarators	{  }
		;
expression_statement : statement_expression ';'	{  }
		;
statement_expression : invocation_expression 	{  }
		| object_creation_expression 	{  }
		| assignment 	{  }
		| pre_increment_expression 	{  }
		| pre_decrement_expression	{  }
		;
selection_statement : if_statement 	{  }
		| switch_statement	{  }
		;
if_statement : IF '(' boolean_expression ')' embedded_statement 	{ } %prec IFX
		| IF '(' boolean_expression ')' embedded_statement ELSE embedded_statement	{  }
		;
switch_statement : SWITCH '(' expression ')' switch_block	{  }
		;
switch_block : '{' '}' 	{  }
		| '{' switch_sections '}'	{  }
		;
switch_sections : switch_section 	{  }
		| switch_sections switch_section	{  }
		;
switch_section : switch_labels statement_list	{  }
		;
switch_labels : switch_label 	{  }
		| switch_labels switch_label	{  }
		;
switch_label : CASE constant_expression ':' 	{  }
		| DEFAULT ':'	{  }
		;
iteration_statement : while_statement 	{  }
		| do_statement 	{  }
		| for_statement 	{  }
		| foreach_statement	{  }
		;
while_statement : WHILE '(' boolean_expression ')' embedded_statement	{  }
		;
do_statement : DO embedded_statement WHILE '(' boolean_expression ')' ';'	{  }
		;
for_statement : FOR '(' ';' ';' ')' embedded_statement 	{  }
		| FOR '(' for_initializer ';' ';' ')' embedded_statement 	{  }
		| FOR '(' ';' for_condition ';' ')' embedded_statement 	{  }
		| FOR '(' ';' ';' for_iterator ')' embedded_statement 	{  }
		| FOR '(' for_initializer ';' for_condition ';' ')' embedded_statement 	{  }
		| FOR '(' for_initializer ';' ';' for_iterator ')' embedded_statement 	{  }
		| FOR '(' ';' for_condition ';' for_iterator ')' embedded_statement 	{  }
		| FOR '(' for_initializer ';' for_condition ';' for_iterator ')' embedded_statement	{  }
		;
for_initializer : local_variable_declaration 	{  }
		| statement_expression_list	{  }
		;
for_condition : boolean_expression	{  }
		;
for_iterator : statement_expression_list	{  }
		;
statement_expression_list : statement_expression 	{  }
		| statement_expression_list ',' statement_expression	{  }
		;
foreach_statement : FOREACH '(' local_variable_type identifier IN expression ')' embedded_statement	{  }
		;
jump_statement : break_statement 	{  }
		| continue_statement 	{  }
		| goto_statement 	{  }
		| return_statement 	{  }
		| throw_statement	{  }
		;
break_statement : BREAK ';'	{  }
		;
continue_statement : CONTINUE ';'	{  }
		;
goto_statement : GOTO identifier ';' 	{  }
		| GOTO CASE constant_expression ';' 	{  }
		| GOTO DEFAULT ';'	{  }
		;
return_statement : RETURN ';' 	{  }
		| RETURN expression ';'	{  }
		;
throw_statement : THROW ';' 	{  }
		| THROW expression ';'	{  }
		;
try_statement : TRY block catch_clauses 	{  }
		| TRY block finally_clause 	{  }
		| TRY block catch_clauses finally_clause	{  }
		;
catch_clauses : general_catch_clause	{  }
		;
general_catch_clause : CATCH block	{  }
		;
finally_clause : FINALLY block	{  }
		;
using_statement : USING '(' resource_acquisition ')' embedded_statement	{  }
		;
resource_acquisition : local_variable_declaration 	{  }
		| expression	{  }
		;

/*B.2.6 Namespaces*/ 
compilation_unit : using_directives namespace_member_declarations 	{ $$ = $2; }
		| namespace_member_declarations 	{ $$ = $1; }
		| using_directives 	{  }
		| epsilon	{  }
		;
namespace_declaration :	NAMESPACE qualified_identifier namespace_body 	{ $$ = $2; }
		| NAMESPACE qualified_identifier namespace_body ';'	{ $$ = $2; }
		;
qualified_identifier :	identifier 	{ $$ = $1; }
		| qualified_identifier '.' identifier	{ $$ = $3; }
		;
namespace_body : '{' '}' 	{  }
		| '{' namespace_member_declarations '}' 	{  }
		| '{' using_directives '}' 	{ $$ = $2; }
		| '{' using_directives namespace_member_declarations '}'	{  }
		;
using_directives : using_directive 	{ $$ = $1; }
		| using_directives using_directive	{  }
		;
using_directive : using_alias_directive 	{  }
		| using_namespace_directive	{ $$ = $1; }
		;
using_alias_directive : USING identifier '=' namespace_or_type_name ';'	{  }
		;
using_namespace_directive : USING namespace_name ';'	{ $$ = $2; }
		;
namespace_member_declarations : namespace_member_declaration 	{  }
		| namespace_member_declarations namespace_member_declaration	{  }
		;
namespace_member_declaration : namespace_declaration 	{  }
		| struct_declaration	{  }
		| class_declaration     {  }
		;
qualified_alias_member : identifier DCLN identifier 	{ $$ = $1; }
		;

/*B.2.7 Classes;*/ 
class_declaration : CLASS identifier class_body 	{ $$ = $2; }
		| modifiers CLASS identifier class_body 	{  }
		| CLASS identifier class_base class_body 	{  }
		| CLASS identifier class_body ';' 	{  }
		| modifiers CLASS identifier class_base class_body 	{  }
		| modifiers CLASS identifier class_body ';' 	{  }
		| CLASS identifier class_base class_body ';' 	{  }
		| modifiers CLASS identifier class_base class_body ';' 	{  }
		;
modifiers : modifier 	{ $$ = $1; }
		| modifiers modifier	{  }
		;
modifier : NEW 	{ 
			genNode* newNode = new genNode();
			$$ = newNode;
			$$->place = string($1);
		}
		| PUBLIC 		{ 
			genNode* newNode = new genNode();
			$$ = newNode;
			$$->place = string($1);
		}
		| PROTECTED 	{ 
			genNode* newNode = new genNode();
			$$ = newNode;
			$$->place = string($1);
		}
		| PRIVATE	{ 
			genNode* newNode = new genNode();
			$$ = newNode;
			$$->place = string($1);
		}
		;
class_base : ':' class_type	{ $$ = $2; }
		;
class_body : '{' '}' 	{ 
			genNode* newNode = new genNode();
			$$ = newNode; 
		}
		| '{' class_member_declarations '}'	{ $$ = $2; }
		;
class_member_declarations : class_member_declaration 	{  }
		| class_member_declarations class_member_declaration	{  }
		;
class_member_declaration : constant_declaration 	{  }
		| field_declaration 	{  }
		| method_declaration 	{  }
		| constructor_declaration 	{  }
		| destructor_declaration 	{  }
		| struct_declaration	{  }
		;
constant_declaration : CONST type constant_declarators ';' 	{  }
		| modifiers CONST type constant_declarators ';'	{  }
		;

constant_declarators : constant_declarator  	{  }
		| constant_declarators ',' constant_declarator	{  }
		;
constant_declarator : identifier '=' constant_expression	{  }
		;
field_declaration : type variable_declarators ';' 	{  }
		| modifiers type variable_declarators ';'	{  }
		;

variable_declarators : variable_declarator 	{  }
		| variable_declarators ',' variable_declarator	{  }
		;
variable_declarator : identifier 	{  }
		| identifier '=' variable_initializer;	
variable_initializer : expression 	{  }
		| array_initializer	{  }
		;
method_declaration : method_header method_body	{  }
		;
method_header : type member_name '(' ')' 	{  }
		| modifiers type member_name '(' ')' 	{  }
		| type member_name '(' formal_parameter_list ')' 	{  }
		| modifiers type member_name '(' formal_parameter_list ')' 	{ $$ = $2; }
		| VOID member_name '(' ')' 	{  }
		| modifiers VOID member_name '(' ')' 	{  }
		| VOID member_name '(' formal_parameter_list ')' 	{  }
		| modifiers VOID member_name '(' formal_parameter_list ')' 	{  }
		;

member_name : qualified_identifier	{ $$ = $1; }
		;
method_body : block 	{ $$ = $1; }
		| ';'	{ $$ = NULL; }
		;
formal_parameter_list : fixed_parameters 	{ $$ = $1; }
		| fixed_parameters ',' parameter_array 	{  }
		| parameter_array	{  }
		;
fixed_parameters : fixed_parameter 	{ $$ = $1; }
		| fixed_parameters ',' fixed_parameter	{  }
		;
fixed_parameter : type identifier 	{ $$ = $1; }
		| parameter_modifier type identifier 	{  }
		| type identifier default_argument 	{  }
		| parameter_modifier type identifier default_argument	{  }
		;
default_argument : '=' expression	{  }
		;
parameter_modifier : REF 	{  }
		| THIS	{  }
		;
parameter_array : PARAMS array_type identifier	{  }
		;
constructor_declaration : constructor_declarator constructor_body 	{  }
		| modifiers constructor_declarator constructor_body	{  }
		;
		
constructor_declarator : identifier '(' ')' 	{  }
		| identifier '(' ')' constructor_initializer 	{  }
		| identifier '(' formal_parameter_list ')' 	{  }
		| identifier '(' formal_parameter_list ')' constructor_initializer	{  }
		;
constructor_initializer : ':' BASE '(' ')' 	{  }
		| ':' BASE '(' argument_list ')' 	{  }
		| ':' THIS '(' ')' 	{  }
		| ':' THIS '(' argument_list ')'	{  }
		;
constructor_body : block 	{  }
		| ';'	{  }
		;
destructor_declaration : '~' identifier '(' ')' destructor_body	{  }
		;
destructor_body : block 	{  }
		| ';'	{  }
		;

/*B.2.8 Structs*/ 
struct_declaration : STRUCT identifier struct_body 	{  }
		| modifiers STRUCT identifier struct_body 	{  }
		| STRUCT identifier struct_body ';' 	{  }
		| modifiers STRUCT identifier struct_body ';' 	{  }
		;

struct_body : '{' '}' 	{  }
		| '{' struct_member_declarations '}'	{  }
		;
struct_member_declarations : struct_member_declaration 	{  }
		| struct_member_declarations struct_member_declaration	{  }
		;
struct_member_declaration : constant_declaration 	{  }
		| field_declaration 	{  }
		| method_declaration 	{  }
		| constructor_declaration 	{  }
		;

/*B.2.9 Arrays*/ 
array_type : non_array_type rank_specifier	{ 
			genNode* newNode = new genNode();
			$$ = newNode;
		}
		;
rank_specifier : '[' ']' 	{ $$ = "[]";  }
		| '[' ',' ']'	{ $$ = "[,]" ;}
		;
array_initializer : '{' '}' 	{  }
		| '{' variable_initializer_list '}' 	{  }
		| '{' variable_initializer_list ',' '}'	{  }
		;
variable_initializer_list : variable_initializer 	{  }
		| variable_initializer_list ',' variable_initializer	{  }



epsilon : 	%empty 		{}
			;

%%	

extern FILE *yyin;

extern void yyerror(char *c){
		cout << "Error at line: " << 1234555 << "\n" << c << endl;
		exit(1);	
	}


int main(int argc, char* argv[]){
	FILE *file;
	if (argc==2 &&(file=fopen(argv[1],"r")))
		yyin = file;
	else if (argc!=2){
		cerr<< "Exactly one file has to be passed as argument!\n";
		exit(1);
	}
	else{
		cerr<< "Please specify correct file name\n";
		exit(1);
	}
	yydebug = 0;
	yyparse();
	/*
	cerr << "==================================================\n";
	cerr << "                 PARSING COMPLETE\n";
	cerr << "==================================================\n";
	*/
	fclose(file);
	return 0;
}
